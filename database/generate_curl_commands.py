#!/usr/bin/env python3
"""
Script pour parser l'API backend des h√©ros et g√©n√©rer des commandes curl
pour recr√©er les h√©ros dans une nouvelle base de donn√©es.
"""

import os
import sys
import json
import requests
import time
from datetime import datetime
from typing import List, Dict, Any, Optional
from pathlib import Path

# Chargement du fichier .env s'il existe
def load_env_file():
    """Charge le fichier .env dans l'environnement"""
    env_file = Path(__file__).parent / '.env'
    if env_file.exists():
        with open(env_file, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    os.environ[key.strip()] = value.strip()

# Charger les variables d'environnement
load_env_file()

# Configuration
API_BASE = "http://127.0.0.1:8000/api"
ADMIN_PASSWORD = os.getenv("ADMIN_PASSWORD")

if not ADMIN_PASSWORD:
    print("‚ùå ERREUR: Variable d'environnement ADMIN_PASSWORD non d√©finie")
    print("üí° Veuillez d√©finir ADMIN_PASSWORD dans votre fichier .env")
    sys.exit(1)

class HerosCurlGenerator:
    def __init__(self, api_base: str, password: str):
        self.api_base = api_base
        self.password = password
        self.token = None
        self.session = requests.Session()
        
    def wait_for_api(self, max_attempts: int = 30) -> bool:
        """Attend que l'API soit disponible"""
        print("üîç V√©rification de la disponibilit√© de l'API...")
        
        for attempt in range(max_attempts):
            try:
                response = self.session.get(f"{self.api_base}/heroes/", timeout=5)
                if response.status_code in [200, 401]:  # 401 = pas authentifi√© mais API OK
                    print("‚úÖ API disponible")
                    return True
            except requests.exceptions.RequestException:
                if attempt < max_attempts - 1:
                    print(f"‚è≥ Tentative {attempt + 1}/{max_attempts}...")
                    time.sleep(1)
                    continue
                
        print("‚ùå API non disponible")
        return False
    
    def authenticate(self) -> bool:
        """S'authentifie aupr√®s de l'API"""
        try:
            response = self.session.post(
                f"{self.api_base}/auth/login",
                json={"password": self.password},
                timeout=10
            )
            
            if response.status_code == 200:
                self.token = response.json()["access_token"]
                self.session.headers.update({"Authorization": f"Bearer {self.token}"})
                return True
            else:
                print(f"‚ùå √âchec authentification: {response.status_code}")
                return False
                
        except requests.exceptions.RequestException as e:
            print(f"‚ùå Erreur authentification: {e}")
            return False
    
    def get_heroes(self) -> Optional[List[Dict[str, Any]]]:
        """R√©cup√®re la liste des h√©ros depuis l'API"""
        try:
            response = self.session.get(f"{self.api_base}/heroes/", timeout=10)
            
            if response.status_code == 200:
                heroes = response.json()
                print(f"üìã {len(heroes)} h√©ros r√©cup√©r√©s depuis l'API")
                return heroes
            else:
                print(f"‚ùå Erreur r√©cup√©ration h√©ros: {response.status_code}")
                return None
                
        except requests.exceptions.RequestException as e:
            print(f"‚ùå Erreur r√©seau: {e}")
            return None
    
    def filter_test_heroes(self, heroes: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Filtre les h√©ros de test"""
        filtered_heroes = []
        test_keywords = ['test', 'demo', 'example', 'sample']
        
        for hero in heroes:
            nickname = hero.get('nickname', '').lower()
            description = hero.get('description', '')
            
            # Exclure si le nickname contient des mots-cl√©s de test
            if any(keyword in nickname for keyword in test_keywords):
                print(f"üóëÔ∏è  Exclu (test): {hero.get('nickname')}")
                continue
            
            # Exclure si la description est tr√®s courte (probablement un test)
            if len(description) < 50:
                print(f"üóëÔ∏è  Exclu (description courte): {hero.get('nickname')}")
                continue
            
            print(f"‚úÖ Inclus: {hero.get('nickname')} ({hero.get('real_name', 'N/A')})")
            filtered_heroes.append(hero)
        
        print(f"üìä {len(filtered_heroes)} h√©ros conserv√©s, {len(heroes) - len(filtered_heroes)} exclus")
        return filtered_heroes
    
    def escape_json_for_bash(self, data: Dict[str, Any]) -> str:
        """√âchappe correctement le JSON pour bash"""
        json_str = json.dumps(data, ensure_ascii=False, separators=(',', ':'))
        # √âchapper les caract√®res sp√©ciaux pour bash
        json_str = json_str.replace("'", "'\"'\"'")  # √âchapper les apostrophes
        json_str = json_str.replace('"', '\\"')      # √âchapper les guillemets
        return json_str
    
    def generate_curl_commands(self, heroes: List[Dict[str, Any]]) -> str:
        """G√©n√®re un fichier avec les commandes curl pour recr√©er les h√©ros"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_filename = f"hero_curl_commands_{timestamp}.sh"
        
        # En-t√™te du fichier
        curl_commands = [
            "#!/bin/bash",
            "# Commandes curl pour recr√©er les h√©ros",
            f"# G√©n√©r√© automatiquement le {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"# Contient {len(heroes)} h√©ros",
            "",
            "# Configuration",
            f'API_BASE="{self.api_base}"',
            "",
            "# Chargement du fichier .env s'il existe",
            "if [ -f .env ]; then",
            "    export $(cat .env | grep -v '^#' | xargs)",
            "fi",
            "",
            f'ADMIN_PASSWORD="${{ADMIN_PASSWORD}}"',
            "",
            "# V√©rification des variables d'environnement",
            "if [ -z \"$ADMIN_PASSWORD\" ]; then",
            "    echo \"‚ùå ERREUR: Variable d'environnement ADMIN_PASSWORD non d√©finie\"",
            "    echo \"üí° Veuillez d√©finir ADMIN_PASSWORD dans votre fichier .env\"",
            "    exit 1",
            "fi",
            "",
            "# Fonction d'authentification",
            "authenticate() {",
            "    echo \"üîë Authentification...\"",
            "    TOKEN=$(curl -s -X POST \"$API_BASE/auth/login\" \\",
            "        -H \"Content-Type: application/json\" \\",
            "        -d '{\"password\": \"'$ADMIN_PASSWORD'\"}' | \\",
            "        python3 -c \"import sys, json; print(json.load(sys.stdin)['access_token'])\" 2>/dev/null)",
            "    ",
            "    if [ -z \"$TOKEN\" ]; then",
            "        echo \"‚ùå √âchec de l'authentification\"",
            "        exit 1",
            "    fi",
            "    ",
            "    echo \"‚úÖ Token obtenu\"",
            "}",
            "",
            "# Authentification",
            "authenticate",
            "",
            "echo \"ü¶∏‚Äç‚ôÇÔ∏è CR√âATION DES H√âROS\"",
            "echo \"========================\"",
            ""
        ]
        
        # G√©n√©ration des commandes pour chaque h√©ros
        for i, hero in enumerate(heroes, 1):
            nickname = hero.get('nickname', f'Hero_{i}')
            
            # Pr√©parer les donn√©es du h√©ros (sans l'ID)
            hero_data = {k: v for k, v in hero.items() if k not in ['id', 'created_at', 'updated_at']}
            
            # Cr√©er un fichier JSON temporaire pour ce h√©ros
            json_filename = f"hero_{i}_{timestamp}.json"
            
            curl_commands.extend([
                f"# H√©ros {i}: {nickname}",
                f"echo \"üìù Cr√©ation de: {nickname}\"",
                f"cat > {json_filename} << 'EOF'",
                json.dumps(hero_data, ensure_ascii=False, indent=2),
                "EOF",
                "",
                f"curl -s -X POST \"$API_BASE/heroes/\" \\",
                f"    -H \"Authorization: Bearer $TOKEN\" \\",
                f"    -H \"Content-Type: application/json\" \\",
                f"    -d @{json_filename} | \\",
                f"    python3 -c \"import sys, json; data=json.load(sys.stdin); print('‚úÖ Cr√©√©: ' + data.get('nickname', 'N/A'))\" 2>/dev/null || echo \"‚ùå Erreur pour {nickname}\"",
                "",
                f"rm -f {json_filename}",
                "sleep 0.5",
                ""
            ])
        
        # Pied de fichier
        curl_commands.extend([
            "echo \"üéâ Cr√©ation termin√©e!\"",
            "",
            "# V√©rification finale",
            "echo \"üìä V√©rification...\"",
            "curl -s \"$API_BASE/heroes/\" | python3 -c \"import sys, json; heroes = json.load(sys.stdin); print('Total: ' + str(len(heroes)) + ' h√©ros dans la base')\""
        ])
        
        # √âcriture du fichier
        with open(output_filename, 'w', encoding='utf-8') as f:
            f.write('\n'.join(curl_commands))
        
        # Rendre le fichier ex√©cutable
        os.chmod(output_filename, 0o755)
        
        print(f"üêö Fichier curl g√©n√©r√©: {output_filename}")
        return output_filename
    
    def show_summary(self, heroes: List[Dict[str, Any]]):
        """Affiche un r√©sum√© des h√©ros qui seront recr√©√©s"""
        print(f"\n{'='*60}")
        print(f"üìä R√âSUM√â DES H√âROS √Ä RECR√âER ({len(heroes)} h√©ros)")
        print(f"{'='*60}")
        
        for i, hero in enumerate(heroes, 1):
            skills_count = len(hero.get('skills', {}))
            desc_length = len(hero.get('description', ''))
            
            print(f"\n{i}. {hero.get('nickname', 'N/A')}")
            print(f"   üë§ {hero.get('real_name', 'N/A')}")
            print(f"   üìù Description: {desc_length} caract√®res")
            print(f"   üéØ Comp√©tences: {skills_count}")
            
            if hero.get('skills'):
                skills_str = ', '.join([f"{k}:{v}" for k, v in hero['skills'].items()])
                print(f"      {skills_str}")

def main():
    """Fonction principale"""
    print("ü¶∏‚Äç‚ôÇÔ∏è G√âN√âRATEUR DE COMMANDES CURL POUR H√âROS")
    print("=" * 50)
    
    generator = HerosCurlGenerator(API_BASE, ADMIN_PASSWORD)
    
    # V√©rifier l'API
    if not generator.wait_for_api():
        sys.exit(1)
    
    # S'authentifier
    if not generator.authenticate():
        sys.exit(1)
    print("‚úÖ Authentification r√©ussie")
    
    # R√©cup√©rer les h√©ros
    all_heroes = generator.get_heroes()
    if not all_heroes:
        print("‚ùå Aucun h√©ros trouv√©")
        sys.exit(1)
    
    # Filtrer les h√©ros de test
    heroes = generator.filter_test_heroes(all_heroes)
    if not heroes:
        print("‚ùå Aucun h√©ros valide apr√®s filtrage")
        sys.exit(1)
    
    # G√©n√©rer le fichier de commandes curl
    curl_file = generator.generate_curl_commands(heroes)
    
    # Afficher le r√©sum√©
    generator.show_summary(heroes)
    
    print(f"\n‚ú® G√©n√©ration termin√©e avec succ√®s!")
    print(f"üìÑ Fichier curl: {curl_file}")
    print(f"\nüí° Pour recr√©er les h√©ros:")
    print(f"   ./{curl_file}")

if __name__ == "__main__":
    main()
